// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package labels classifies issues.
package labels

import (
	"bytes"
	"context"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"log"
	"regexp"
	"strings"

	"golang.org/x/oscar/internal/github"
	"golang.org/x/oscar/internal/llm"
	"rsc.io/markdown"
)

// A Category is a classification for an issue.
type Category struct {
	Name        string // internal unique name
	Label       string // issue tracker label
	Description string
}

// IssueCategory returns the category chosen by the LLM for the issue, along with an explanation
// of why it was chosen. It uses the built-in list of categories.
func IssueCategory(ctx context.Context, cgen llm.ContentGenerator, iss *github.Issue) (_ Category, explanation string, err error) {
	return IssueCategoryFromList(ctx, cgen, iss, config.Categories)
}

// IssueCategoryFromList is like [IssueCategory], but uses the given list of Categories.
func IssueCategoryFromList(ctx context.Context, cgen llm.ContentGenerator, iss *github.Issue, cats []Category) (_ Category, explanation string, err error) {
	if iss.PullRequest != nil {
		return Category{}, "", errors.New("issue is a pull request")
	}

	body := cleanIssueBody(iss.Body)
	// Extract issue text into a string.
	var issueText bytes.Buffer
	err = template.Must(template.New("body").Parse(bodyTemplate)).Execute(&issueText, bodyArgs{
		Title: iss.Title,
		Body:  body,
	})
	if err != nil {
		return Category{}, "", err
	}

	// Build system prompt to ask about the issue category.
	var systemPrompt bytes.Buffer
	systemPrompt.WriteString(categoryPrompt)
	for _, cat := range cats {
		fmt.Fprintf(&systemPrompt, "%s: %s\n", cat.Name, cat.Description)
	}

	// Ask about the category of the issue.
	jsonRes, err := cgen.GenerateContent(ctx, responseSchema,
		[]llm.Part{llm.Text(systemPrompt.String()), llm.Text(issueText.String())})
	if err != nil {
		return Category{}, "", fmt.Errorf("llm request failed: %w\n", err)
	}
	var res response
	if err := json.Unmarshal([]byte(jsonRes), &res); err != nil {
		return Category{}, "", fmt.Errorf("unmarshaling %s: %w", jsonRes, err)
	}
	for _, cat := range cats {
		if res.CategoryName == cat.Name {
			return cat, res.Explanation, nil
		}
	}
	return Category{}, "", fmt.Errorf("no category matches LLM response %q", jsonRes)
}

// TODO(jba): this is approximate.
// See https://developer.mozilla.org/en-US/docs/Web/HTML/Comments for the exact syntax.
var htmlCommentRegexp = regexp.MustCompile(`<!--(\n|.)*?-->`)

// cleanIssueBody adjusts the issue body to improve the odds that it will be properly
// labeled.
func cleanIssueBody(text string) string {
	doc := github.ParseMarkdown(text)

	var cleanBlock func(markdown.Block)
	cleanBlock = func(x markdown.Block) {
		switch x := x.(type) {
		case *markdown.Document:
			for _, sub := range x.Blocks {
				cleanBlock(sub)
			}
		case *markdown.HTMLBlock:
			// Delete comments.
			// Each Text is a line.
			t := strings.Join(x.Text, "\n")
			t = htmlCommentRegexp.ReplaceAllString(t, "")
			x.Text = strings.Split(t, "\n")
		case *markdown.Quote:
			for _, sub := range x.Blocks {
				cleanBlock(sub)
			}
		case *markdown.List:
			for _, sub := range x.Items {
				cleanBlock(sub)
			}
		case *markdown.Item:
			for _, sub := range x.Blocks {
				cleanBlock(sub)
			}
		case *markdown.Heading:
			cleanBlock(x.Text)
		case *markdown.Paragraph:
			cleanBlock(x.Text)
		}
	}
	cleanBlock(doc)
	return markdown.Format(doc)
}

// response is the response that should generated by the LLM.
// It must match [responseSchema].
type response struct {
	CategoryName string
	Explanation  string
}

var responseSchema = &llm.Schema{
	Type: llm.TypeObject,
	Properties: map[string]*llm.Schema{
		"CategoryName": {
			Type:        llm.TypeString,
			Description: "the kind of issue",
		},
		"Explanation": {
			Type:        llm.TypeString,
			Description: "an explanation of why the issue belongs to the category",
		},
	},
}

const categoryPrompt = `
Your job is to categorize Go issues.
The issue is described by a title and a body.
The issue body is encoded in markdown.
Report the category of the issue and an explanation of your decision.
Each category and its description are listed below.

`
const bodyTemplate = `
The title of the issue is: {{.Title}}
The body of the issue is: {{.Body}}
`

type bodyArgs struct {
	Title string
	Body  string
}

var config struct {
	Categories []Category
}

//go:embed static/*
var staticFS embed.FS

func init() {
	f, err := staticFS.Open("static/categories.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	dec := json.NewDecoder(f)
	dec.DisallowUnknownFields()
	if err := dec.Decode(&config); err != nil {
		log.Fatal(err)
	}
}
